trigger:
  branches:
    include:
    - main
    - release-v*

pr:
  branches:
    include:
    - main
    - release-v* # want this to be release-v* or v*?

variables:
  KUBECONFIG: $(System.DefaultWorkingDirectory)/kubeconfig.json

stages:
- stage: build
  pool:
    vmImage: ubuntu-latest # Default agent pool for Azure Pipelines
  jobs:
    - job: build_docker_images
      steps:
      - task: DockerInstaller@0
        inputs:
          dockerVersion: '17.09.0-ce' # string. Required. Docker Version. Default: 17.09.0-ce.
      - template: ./templates/install-kind.yaml
        parameters:
          kind_version: 0.17.0
      - bash: docker version
        displayName: Ensure docker installation succeeded
      - bash: docker login -u $(docker.registry) -p "$DOCKER_PASSWORD"
        displayName: Login to docker registry
        env:
          DOCKER_PASSWORD: $(docker.password)
      - bash: |
          echo "##vso[task.setvariable variable=IMAGE_TAG]$(git rev-parse --short HEAD)"
          echo $IMAGE_TAG
        displayName: Set IMAGE_TAG based on git commit
      - template: ./templates/build-and-push-image.yaml
        parameters:
          image_registry: $(docker.registry)
          image_name: $(client.image.name)
          image_tag: $IMAGE_TAG
          dockerfile_path: ./ado-pipeline-go-microservice-app/client
      - template: ./templates/build-and-push-image.yaml
        parameters:
          image_registry: $(docker.registry)
          image_name: $(server.image.name)
          image_tag: $(IMAGE_TAG)
          dockerfile_path: ./ado-pipeline-go-microservice-app/server

- stage: test
  pool:
    vmImage: ubuntu-latest # Default agent pool for Azure Pipelines
  jobs:
    - job: test_microservice_app
      steps:
      - template: ./templates/create-kind-cluster.yaml
        parameters:
          cluster_name: kind-test
      - bash: |
          echo "##vso[task.setvariable variable=IMAGE_TAG]$(git rev-parse --short HEAD)"
          echo $IMAGE_TAG
        displayName: Set IMAGE_TAG based on git commit
      - bash: kubectl get pods -A
        displayName: Get pods
      - bash: |
          kubectl create ns $client_image_name
          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: $client_image_name
            namespace: $client_image_name
            labels:
              app: $client_image_name
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: $client_image_name
            template:
              metadata:
                labels:
                  app: $client_image_name
              spec:
                containers:
                - name: $client_image_name
                  image: $registry/$client_image_name:$client_image_tag
                  imagePullPolicy: Always
                  command: ["/client"]
          EOF
        displayName: Create client deployment
        env:
          client_image_name: $(client.image.name)
          client_image_tag: $(IMAGE_TAG)
          registry: $(docker.registry)
      - template: ./templates/wait-for-deployment.yaml
        parameters:
          max_retries: 30
          interval_seconds: 10
          deployment_name: client
          deployment_namespace: client
      - bash: |
          kubectl create ns $server_image_name
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Service
          metadata:
            name: $server_image_name
            namespace: $server_image_name
            labels:
              app: $server_image_name
          spec:
            ports:
            - port: 8080
              name: server-port
            selector:
              app: $server_image_name
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: $server_image_name
            namespace: $server_image_name
            labels:
              app: $server_image_name
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: $server_image_name
            template:
              metadata:
                labels:
                  app: $server_image_name
              spec:
                containers:
                - name: $server_image_name
                  image: $registry/$server_image_name:$server_image_tag
                  imagePullPolicy: Always
                  command: ["/server"]
          EOF
        displayName: Create server deployment
        env:
          server_image_name: $(server.image.name)
          server_image_tag: $(IMAGE_TAG)
          registry: $(docker.registry)
      - template: ./templates/wait-for-deployment.yaml
        parameters:
          max_retries: 30
          interval_seconds: 10
          deployment_name: server
          deployment_namespace: server
      - bash: |
          resp=$(kubectl exec "$(kubectl get pod -l app=$client_pod_label -n $client_pod_label -o jsonpath='{.items[0].metadata.name}')" -n $client_pod_label -- curl --write-out '%{http_code}' http://localhost:8080/send-req --silent --output /dev/null)
          if [[ "$resp" != "200" ]]; then
            echo "curl request from client to server didn't return response code 200" && exit 1
          fi
        displayName: Test curl against client pod
        env:
          client_pod_label: $(client.image.name)
      - bash: |
          client_logs=$(kubectl logs $(kubectl get pod -l app=$client_pod_label -n $client_pod_label -o jsonpath='{.items[0].metadata.name}') -n $client_pod_label)
          if [[ "$(echo $client_logs | head -c 19)" != "Response Successful" ]]; then
            echo "Client logs don't have 'Response Successful'" && exit 1
          fi
        displayName: Verify client pod logs
        env:
          client_pod_label: $(client.image.name)
      - bash: |
          server_logs=$(kubectl logs $(kubectl get pod -l app=$server_pod_label -n $server_pod_label -o jsonpath='{.items[0].metadata.name}') -n $server_pod_label)
          if [[ "$(echo $server_logs | head -c 5)" != "Hello" ]]; then
            echo "Server logs don't have 'Hello'" && exit 1
          fi
        env:
          server_pod_label: $(server.image.name)
      - bash: |
          kind delete cluster --name kind-test
        displayName: Delete kind cluster
        condition: always() # We want to delete the kind cluster regardless if the tests pass or fail. 


## Delete kind cluster once tests pass


## Publish stage that only gets enabled / triggered for release job? 

# Push to staging registry (or as test tag) before publishing to official registry?
# Or distinguish between CI and release Pipeline? 
